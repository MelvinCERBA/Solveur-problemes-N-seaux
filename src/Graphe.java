import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.LinkedList;

import static java.lang.Math.abs;

public class Graphe {
    /**
     * State diagram of a given "buckets problem"
     */

    Etat etat_final;                // Final state, goal of the problem

    LinkedList<Etat> Ouverts;       // Nodes (Etats) that can be generated from already explored nodes (and have not been yet)
    LinkedList<Etat> Fermes;        // Nodes that have been explored

    String type_parcours;           // search type (depth-first, breadth-first or best-first)
    String heuristique;             // heuristic chosen for the best-first search

    LinkedList<String> solution;    // Linked-List that will contain the path (succession of rules applied) to the final state when it's found


    public Graphe(Etat f, String parcours, String h){
        /**
         * Creates the state diagram to be used in order to solve the "buckets problem" whose final state is f
         */

        // Set the given state as final state
        etat_final                  = f;

        // Create the initial state
        int[] seaux_initial         = new int[f.seaux.length];
        Arrays.fill(seaux_initial, 0);
        Etat etat_initial           = new Etat(seaux_initial,etat_final.capacite_Seaux);

        // Initialize Open and Closed lists
        Ouverts                     = new LinkedList<>();
        Ouverts.add(etat_initial);
        Fermes                      = new LinkedList<>();

        // Set the search type and heuristic to those demanded
        type_parcours               = parcours;
        heuristique                 = h;

        // Initialize the solution
        solution                    = new LinkedList<>();
    }

    public boolean resoudre(){
        /**
         * Solves the problem by exploring the state diagram according to the search type (and heuristic) selected
         *
         * returns "true" if the problem has a solution, "false" if not
         * Sets "solution" to the path to the final state (if there is indeed a solution)
         */

        while (!Ouverts.isEmpty()){
            //trierOuverts(heuristique);
            switch (type_parcours){

                // Depth-first search (LIFO)
                case "p":
                    Etat sommetPile = Ouverts.pop();
                    if(sommetPile.estEgal(etat_final)){
                        solution = sommetPile.chemin;
                        return true;
                    }
                    ajouterFermes(sommetPile);
                    explorer(sommetPile);
                    break;

                // Breadth-first and best-first searches  (FIFO)
                default:                                       // Best-first uses the same FIFO algorithm as breadth-first
                    Etat tete_file = Ouverts.removeFirst();    // because new nodes are inserted into "Ouverts" at an index
                    if(tete_file.estEgal(etat_final)){         // defined by their heuristic score. The node with the lowest
                        solution = tete_file.chemin;           // score is therefore always the first element of the linked-list
                        return true;
                    }
                    ajouterFermes(tete_file);
                    explorer(tete_file);
                    break;
            }
        }

        //System.out.println("Pas de solution.");
        return false;
    }

    public void explorer(Etat e){
        /**
         * Adds to "ouvert" the states that can be generated from e (if similar states haven't been explored already)
         */
        Etat fils;

        // states that can be generated by the "remplir" rule
        for(int s:e.seaux_nonPleins()){
            fils = e.remplir(s);
            if(!explored(fils)){
                ajouterOuverts(fils);
            }
        }

        // states that can be generated by the "vider" rule
        for(int s:e.seaux_nonVides()){
            fils = e.vider(s);
            if(!explored(fils)){
                ajouterOuverts(fils);
            }
            // states that can be generated by the "transvaser" rule
            for(int k:e.seaux_nonPleins()){
                fils = e.transvaser(s,k);
                if(!explored(fils)){
                    ajouterOuverts(fils);
                }
            }
        }
    }

//    public void explorer(Etat e){ //version opti
//        Etat fils;
//        int[] S = e.seaux;
//        for(int i=0; i < S.length; i++){
//            if(S[i]!=e.capacite_Seaux[i]){ // si le seau est rempli, intutile de le remplir
//                continue;
//            }
//            fils = e.remplir(i);
//            if(!explored(fils)){
//                ajouterOuverts(fils); // on ajoute l'état généré par "remplir seau i"
//            }
//        }
//        for(int i=0; i < S.length; i++){
//            if(S[i]==0){
//                continue;
//            }
//            fils = e.vider(i);
//            if(!explored(fils)){
//                ajouterOuverts(fils); // on ajoute l'état généré par "vider seau i"
//            }
//            for(int k=0; k < S.length; k++){
//                if(S[k]==e.capacite_Seaux[k]){
//                    continue;
//                }
//                fils = e.transvaser(i,k);
//                if(!explored(fils)){
//                    ajouterOuverts(fils); // on ajoute l'état généré par "transvaser seau i dans seau k"
//                }
//            }
//        }
//    }

    public void ajouterOuverts(Etat etat){
        /**
         * Adds a state to "Ouvert". Places it according to its heuristic score if a heuristic has been chosen
         */

        int score;      // heuristic score (used only if a heuristic has been chosen when creating the Graphe object)

        switch(heuristique){

            // Basic heuristic : difference between the final state buckets content and the evaluated state buckets content
            case "basique":
                etat.scoreHeuristique       = abs(Arrays.stream(etat.seaux).sum() - Arrays.stream(etat_final.seaux).sum());
                break;

            // "Varied operation" : values the states obtained through varied rules
            case "OperationsVariees":
                score                       = etat.nbrRV-(2*etat.nbrT);
                etat.scoreHeuristique       = abs(score);

            // "Bucket by Bucket distance" : its actually the same as the basic heuristique...
            case "DistParSeau":
                score                       = 0;
                for(int i = 0; i<etat.seaux.length; i++){
                    score                   += abs(etat_final.seaux[i] - etat.seaux[i]);
                }
                etat.scoreHeuristique       = score;

            // Simply add the state if no heuristic was chosen (used for depth-first and breadth-first searches)
            default:
                etat.scoreHeuristique       = 0;
                Ouverts.addLast(etat);
                return;
        }

        // Place the state into "Ouvert" according to its heuristic score
        if(Ouverts.size() == 0){
            Ouverts.add(etat);
            return;
        }
        for(int i = 0; i < Ouverts.size(); i++){
            if(Ouverts.get(i).scoreHeuristique > etat.scoreHeuristique){
                Ouverts.add(i,etat);
                return;
            }
        }
        Ouverts.addLast(etat); // (case where the state has the highest heuristic score)
        return;
    }

    public void ajouterFermes(Etat etat){
        /**
         * Adds a state to "Fermes" (so we don't explore it again)
         */
        Fermes.add(etat);
        return;
    }



    public boolean explored(Etat etat){
        /**
         * Returns true if the state or a similar one (same buckets content) has already been explored or is waiting to be explored
         */
        for(Etat e:Ouverts){
            if(e.estEgal(etat)) {
                return true;
            }
        }
        for(Etat e:Fermes){
            if(e.estEgal(etat)) {
                return true;
            }

        }
        return false;
    }
}
